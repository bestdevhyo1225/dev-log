# 오브젝트(코드로 이해하는 객체지향 설계) - 4장

## 상태, 행동

- 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것
- 객체의 책임에 초점을 맞출 것
- 책임은 객체의 상태에서 행동으로, 나아가 객체와 객체 사이의 상호작용으로 설계 중심을 이동시킨다.
    - 결합도가 낮고, 응집도가 높으며, 구현을 효과적으로 캡슐화

## 데이터 중심 설계

- 상태를 분할의 중심축으로 삼는 방법 (상태 == 데이터)
- 객체 내부의 저장되는 데이터를 기반으로 시스템을 분할하는 방법
- 객체 내부에 저장해야 하는 데이터는 무엇인가를 묻는 것으로 시작한다.

## 객체지향 설계

- 책임을 분할의 중심축으로 삼는 방법

## 설계 트레이드 오프

- 변경될 가능성 높은 부분을 구현이라고 한다.
- 상대적으로 안정적인 부분을 인터페이스라고 부른다.
- 변경의 정도에 따라 구현과 인터페이스를 분리하고, 외부에서는 인터페이스만 의존하도록 관계를 조절하는 것이다.
- 설계가 필요한 이유는 요구사항이 변경되고, 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.

### 캡슐화

- 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법
- 변경될 수 있는 어떤 것이라도 캡슐화해야 한다.

### 응집도, 결합도

- 좋은 설계가 변경과 관련된 것이고, 응집도와 결합도의 정도가 설계의 품질을 결정한다면, 응집도와 결합도는 변경과 관련된 것이다.
- 높은 응집도 낮은 결합도는 설계를 변경하기 쉽게 만든다.
- 응집도? 변경이 발생할 때, 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.
- 결합도? 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.

## 데이터 중심 설계인 시스템의 문제점

### 캡슐화 위반

- getter, setter 메서드에 의해 인스턴스의 변수가 존재한다는 사실을 노골적으로 드러낸다.
- 접근자와 수정장에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략(design-by-guessing strategy)이라고 부른다.
- 객체가 사용될 협력을 고려하지 않고, 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행한다.

### 높은 결합도

- 인스턴스 변수의 타입을 변경한다고 가정한다면, getter 메서드의 반환 타입도 함께 수정해야 한다.
- 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중 되어 있다. 따라서 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다는 것이다.
- 위의 결합도로 인해 어떤 데이터 객체를 변경하더라도 제어 객체를 함께 변경할 수밖에 없다.

### 낮은 결합도

- 어떤 요구사항 변경을 수용하기 위해 하나 이상의 클래스를 수정해야 하는 것은 설계의 응집도가 낮다는 증거이다.

## 자율적인 객체를 향해

### 캡슐화 지키기

- 객체에게 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드이다.
- 변경하는 주체를 외부의 객체에서 자신의 객체로 이동시킬 것 (즉, 자신의 스스로 처리하도록 책임을 이동 시키는 것)

### 스스로 자신의 데이터를 책임지는 객체

- 객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서, 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.
- 이 객체가 어떤 데이터를 포함해야 하는가? 질문은 2가지로 분리해야한다.
    - 이 객체가 어떤 데이터를 포함해야 하는가?
    - 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?
