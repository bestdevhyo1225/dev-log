# 영속성 컨텍스트와 JPQL

## JPQL 쿼리 후, 영속 상태인 것과 아닌 것

### 영속 상태

`엔티티 조회` 의 경우에는 영속성 컨텍스트에서 관리한다.

```sql
select m from Member m
```

### 영속 상태가 아님

`임베디드 타입 조회` 의 경우에는 영속성 컨텍스트에서 관리하지 않는다.

- `address` 필드는 `임베디드 타입`

```sql
select o.address from Order o
```

`단순 필드 조회` 의 경우에는 영속성 컨텍스트에서 관리하지 않는다.

```sql
select m.id, m.username from Member m
```

### 정리

조회한 엔티티만 영속성 컨텍스트가 관리한다.

## JPQL로 조회한 엔티티와 영속성 컨텍스트

`JPQL` 로 데이터베이스에서 조회한 엔티티가 영속성 컨텍스트에 `이미 있으면 조회한 결과를 버리고, 영속성 컨텍스트에 있던 엔티티를 반환한다.`

- `JPQL` 로 조회한 엔티티는 영속 상태다.

- 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면, 기존 엔티티를 반환한다.

### 기존 엔티티를 그대로 두고 검색한 엔티티를 버리는 이유

영속성 컨텍스트에 수정 중인 데이터가 사라질 수 있으므로 위험하다. 그리고 영속성 컨텍스트는 영속 상태인 엔티티의 동일성을 보장해야 하기 때문에 기존 엔티티를 그대로 둔다.

- 동일성 : 참조 주소가 같은지

## em.find() vs JPQL

`em.find()` 메서드는 엔티티를 영속성 컨텍스트에서 먼저 찾고 없으면 데이터베이스에서 찾는다. 따라서 해당 엔티티가 영속성 컨텍스트에 있으면 메모리에서 바로 찾으므로 성능상 이점이 있다. (1차 캐시)

`JPQL` 은 `항상` 데이터베이스에 `SQL` 을 실행해서 결과를 조회한다. 그래서 `JPQL` 의 특징을 다시 정리해보자면 다음과 같다.

- `JPQL` 은 항상 데이터베이스를 조회한다.

- `JPQL` 로 조회한 엔티티는 영속 상태이다.

- 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면, 기존 엔티티를 반환한다.

## JPQL과 플러시 모드

기본적으로 플러시 모드는 `AUTO` 이다. `AUTO` 의 의미는 `트랜잭션 커밋 실행` 또는 `JPQL 쿼리 실행` 시 데이터베이스에 데이터를 동기화를 한다는 의미이다.

`COMMIT` 플러시 모드가 있는데 `COMMIT` 플러시 모드를 설정하게 되면 `트랜잭션 커밋 실행` 시에만 데이터베이스에 동기화를 한다. 즉, `JPQL 쿼리 실행` 의 경우에는 동기화를 하지
않고, `트랜잭션 커밋 실행` 의 경우에만 동기화를 한다. `COMMIT` 모드의 경우에는 플러시가 너무 자주 일어나는 상황을 최적화 하기위해 사용하는데 제대로 이해하지 못하고 사용할 경우에는 영속성 컨텍스트와
데이터베이스 간의 데이터 무결성이 일치하지 않으므로 심각한 피해를 줄 수 있다. 
