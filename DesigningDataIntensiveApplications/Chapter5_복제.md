# 5장 - 복제

## 복제 지연 문제

### 읽기 확장

- 대부분이 쓰기보다 읽기 요청이 많은 서비스라면, 많은 팔로워를 만들어 팔로워 간 읽기 요청을 분산하는 매력적인 옵션이 있다.
- 이 접근 방식은 실제로는 **`비동기식 복제`** 에서만 동작한다.
- 동기식 복제를 사용한다면, 아래와 같이 매우 불안정한 상황이 발생할 수 있다.
    - 동기식으로 모든 팔로워에 복제를 시도한다면, 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기가 불가능해진다.
    - 노드가 많아지면, 다운될 가능성도 커진다.

### 비동기식 복제에서 발생하는 문제

- 애플리케이션이 **`비동기 팔로워`** 에서 데이터를 읽을 때, 팔로워가 뒤쳐진다면 지난 정보를 볼 수도 있다.
- 이 상황은 데이터베이스에 명백하게 불일치가 발생하지만, 이런 불일치는 일시적인 상태에 불과하다.
- 데이터베이스에 쓰기를 멈추고 잠시동안 기다리면 팔로워는 결국 따라잡게 되고, 리더와 일치하게 된다. 이런 효과를 **`최종적 일관성`** 이라 한다.

### 비동기식 복제 지연시, 발생할 수 있는 3가지 사례

> 자신이 쓴 내용 읽기

- **`쓰기 후, 읽기 일관성(자신의 쓰기 읽기 일관성)`** 이 필요하다.
- 사용자가 페이지를 재로딩했을 때, 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며, 다른 사용자에 대해서는 보장하지 않는다.
- 다른 사용자의 갱신은 일정 시간 이후까지 보이지 않을 수 있다.
- 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다. 그 밖에는 팔로워에서 읽는다.
    - 즉, 항상 사용자 소유의 프로필은 리더에서 읽고, 다른 사용자의 프로필은 팔로워에서 읽는다.
- 대부분의 사용자가 편집할 가능성이 있다면, 마지막 갱신 시간을 찾아서 마지막 갱신 후, 1분 동안은 리더에서 모든 읽기를 수행한다.
    - 또한, 복제 지연을 모니터링해 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다.

> 단조 읽기

- 2번의 질의 중 팔로워 1로 질의가 됐을 경우 결과가 보였는데, 팔로워 2로 질의가 됐을 경우, 결과가 보이지 않는 경우를 말한다.
- 위의 상황을 통해 `시간이 거꾸로 흐르는` 현상을 목격할 수 있다.
- `단조 읽기` 는 강한 일관성보다는 덜한 보장이지만, 최종적 일관성보다는 더 강한 보장이다.
- 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것이다.
    - 사용자 ID의 해시를 기반으로 복제 서버를 선택한다.
    - 복제 서버가 고장나면, 사용자 질의를 다른 복제 서버로 재라우팅할 필요가 있다.

> 일관된 순서로 읽기

- 파티셔닝된(샤딩된) 데이터베이스에서 발생하는 특징적인 문제인데, 순서가 뒤바껴서 보이는 문제이다.
    - 6장에서 설명

### 복제 지연을 위한 해결책

- 결과가 사용자에게 좋지 않은 경험이라면, **`쓰기 후 읽기`** 와 같은 강한 보장을 제공하게끔 시스템을 설계해야 한다.
- 사실은 복제가 **`비동기식`** 으로 동작하지만, **`동기식`** 으로 동작하는 척 하는 것이 문제 해결 방안이다. 

## 참고

- 데이터 중심 애플리케이션 설계
