## 최장 증가 수열 (Longest Increasing Subsequence)

---

### 최장 증가 수열 (LIS) 알고리즘이란 무엇인가?

* 수열중에서 오름차순 형태로 증가하는 값을 가진 부분 수열중에서 가장 긴 길이를 갖고있는 부분 수열이다.



### 최장 증가 수열 알고리즘 구현

* LIS 알고리즘을 적용하는 방식은 2가지가 있다.

  1. O(N^2) 의 시간 복잡도를 갖는 **다이나믹 프로그래밍(DP)** 방식

  2. O(NlogN) 의 시간 복잡도를 갖는 **이분 탐색을 적용한 알고리즘** 방식

* 데이터의 크기가 적당하다면 문제에서 요구하는 시간내로 풀 수 있을것 같다면 **1번 DP 방식**으로 풀고, 데이터의 크기가 커서 문제에서 요구하는 시간내로 풀 수 없다면 **이분탐색을 적용한 LIS 알고리즘** 으로 해결하면 된다.
  



### 다이나믹 프로그래밍 방식 (DP)

* 예제

> 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
>
> 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.

* 첫 번째로 배열을 모두 탐색하는 것으로 생각하자

```c++
vector<int> dp(n);
vector<int> a(n);
for (int i = 0; i < n; i++) {
  cin >> a[i];
}
// 배열을 모두 탐색해야 한다
for (int i = 0; i < n; i++) {
  ...
}
```

* 두 번째로 현재 i 의 위치에서 이전에 기록해두었던 길이들을 확인해야 한다. 즉 0번째부터 i번째 이전의 인덱스까지 탐색해야 한다.

```c++
vector<int> dp(n);
vector<int> a(n);
for (int i = 0; i < n; i++) {
  cin >> a[i];
}
// 배열을 모두 탐색해야 한다.
for (int i = 0; i < n; i++) {
  // 기록해두어야 하는 배열은 무조건 1로 초기화
  // why? 자기자신 혼자라도 길이는 1이니깐
  dp[i] = 1;
  // 0번째 부터 i인덱스 직전까지 탐색
  for (int j = 0; j < i; j++) {
    ...
  }
}
```

* 세 번째로 현재인덱스( i )의 값이 이전 인덱스( j )들의 값보다 크고, 현재 인덱스( i )에 기록해두었던( dp ) 값보다 이전 인덱스( j )에 기록해두었던( dp ) 값에 1을 더해준 값이 더 크다면 현재 인덱스( i )에 기록해 두었던( dp ) 값을 갱신한다.

```c++
// 생략...
// ...
// ...
for (int i = 0; i < n; i++) {
	dp[i] = 1;
	for (int j = 0; j < i; j++) {
		// 현재값이 이전값보다 크고, 
		// 현재까지의 길이를 기록해뒀던 값보다 이전까지의 길이를 기록해뒀던 값에 1을 더해준 값이 더 크다면
		if (a[i] > a[j] && dp[i] < dp[j] + 1) {
			// 길이를 갱신한다.
			dp[i] = dp[j] + 1;
		}
	}
}
```

* 마지막으로 LIS 를 해결할 때 중요한 특징은 마지막에 저장해둔 값 ( dp[n] ) 에 최장 길이가 있을거라는 생각을 하면 안된다.
* 다음과 같은 반례가 존재한다.

> { 10, 20, 30, 40, 10 } 이 있을때, dp 에 저장되어있는 값은 { 1, 2, 3, 4, 1 } 이기 때문에 마지막 값이 반드시 최장 길이가 있을거라는 보장이 없다.

* 따라서 마지막에는 다음과 같은 처리를 해줘야 한다.

```C++
// 생략...
// ...
// ...
// dp 배열에서 가장 큰 값을 찾도록 해야한다.
int ans = 0;
for (int i = 0; i < n; i++) {
  ans = max(ans, dp[i]);
}

// 결과는 ans
cout << ans << '\n';
```



### 이분탐색을 활용한 LIS 알고리즘 방식

* 위의 예제를 다시 활용해서 보자

> 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
>
> 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.

* 이분탐색을 활용한 알고리즘 방식은 다음과 같다.
  1. lis 배열 마지막에 저장되어있는 값보다 a 배열에 들어있는 현재 값이 크다면, lis 배열에 넣는다.
  2. 그렇지 않다면, 이분탐색을 통해 들어갈 자리를 찾는다.
     ( 이분 탐색에서 파생된 lower_bound 알고리즘을 활용한다. lower_bound 탐색은 원하는 값 k 이상이 처음 나오는 위치를 찾는 과정이다. ) 

```c++
// c++ 내장된 라이브러리를 사용해도 되고, 직접 구현해도 된다.
int my_lower_bound(vector<int>& lis, int lis_index, int target) {
  int left = 0, right = lis_index;
  while (left < right) {
    int mid = (left + right) / 2;
    if (lis[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  return right;
}

int main() {
  // 생략..
  // ...
  // ...
  vector<int> a = {10, 20, 10, 30, 20, 50};
 	int lis_index = 0;
  lis[lis_index] = a[lis_index];
  for (int index = 0; index < a.size(); index++) {
    // lis 배열 마지막에 저장되어있는 값보다 a 배열에 들어있는 현재 값이 크다면
    if (lis[lis_index] < a[index]) {
      // 다음 위치에 값을 넣는다.
      lis[++lis_index] = a[index];
    } else {
 			// 그렇지 않다면, 이분 탐색을 통해 들어갈 자리를 찾는다.
      int result_index = my_lower_bound(lis, lis_index, a[index]);
      lis[result_index] = a[index];
    }
  }
  // answer -> lis_index + 1
}
```

* 다음과 같은 방법으로 데이터가 큰 경우의 LIS 문제를 해결할 수 있다.



---

### 백준 문제

* [11053 - 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

* [11054 - 가장 긴 바이토닉 부분 수열](https://www.acmicpc.net/problem/11054)

* [11722 - 가장 긴 감소하는 부분 수열](https://www.acmicpc.net/problem/11722)

* [12015 - 가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)

* [12738 - 가장 긴 증가하는 부분 수열 3](https://www.acmicpc.net/problem/12738)

* [14002 - 가장 긴 증가하는 부분 수열 4](https://www.acmicpc.net/problem/14002)

* [14003 - 가장 긴 증가하는 부분 수열 5](https://www.acmicpc.net/problem/14003)

* [2631 - 줄세우기](https://www.acmicpc.net/problem/2631)

* [2565 - 전깃줄](https://www.acmicpc.net/problem/2565)

  

