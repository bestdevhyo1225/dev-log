## 최소 스패닝 트리 (Minimum Spanning Tree, MST)

---

### 스패닝 트리(Spanning Tree) 란?

- **그래프 내의 모든 정점을 포함하는 트리**
- 스패닝 트리 = 신장 트리
- 스패닝 트리는 그래프의 **최소 연결 부분 그래프** 이다.
  - 최소 연결의 의미? 간선의 수가 가장 적다.
  - N 개의 정점을 가지는 그래프의 최소 간선의 수는 N - 1 개이고, N - 1 개의 간선으로 연결되어 있으면 **필연적으로 트리 형태**가 되고 이것이 바로 **스패닝 트리** 이다.
  - **즉, 일부 간선을 선택해서 만든 트리**
- 트리 형태여야 한다는 말? 선택된 간선들이 **사이클을 이루지 않는다는 의미**이다.
- 정점들이 꼭 부모 - 자식 관계로 연결될 필요는 없다는데 유의하자.

### 스패닝 트리 (Spanning Tree) 의 특징

![image](https://user-images.githubusercontent.com/23515771/103049502-41d8a600-45d5-11eb-830e-8b460163a7cc.png)

- (b) 는 (a) 에 표시된 올바른 스패닝 트리이다.
- (c) 에서 붉은색으로 표시된 간선들은 스패닝 트리가 아니다. **사이클이 있고, 그래프가 하나로 연결되어 있지 않기 때문이다.**
- (a) 의 그래프에서도 **여러 개의 스패닝 트리**가 있음을 쉽게 알 수 있다.
- 즉, 하나의 그래프에는 많은 스패닝 트리(신장 트리)가 존재할 수 있다.
- DFS 와 BFS 을 이용하여 그래프에서 스패닝 트리(신장 트리)를 찾을 수 있다.

### 스패닝 트리 (Spanning Tree) 의 적용 사례

- 통신 네트워크 구축

<img src="https://gmlwjd9405.github.io/images/algorithm-mst/spanning-tree-example.png" width="500px" height="250px">

- 회사 내의 모든 전화기를 **가장 적은수의 케이블** 을 사용하여 연결하고자 하는 경우

- N 개의 위치를 연결하는 통신 네트워크를 **최소의 링크(간선)** 를 이용하여 구축하고자 하는 경우
  ( 최소 링크수는 N - 1개가 되기 때문에 이것은 스패닝 트리가 가능해 진다. )

### 최소 스패닝 트리 (Minimum Spanning Tree, MST) 란?

- 스패닝 트리중에서 사용된 간선들의 **가중치 합이 최소인 트리**를 찾는 문제를 최소 스패닝 트리 문제라고 한다.
- 돌려서 말하자면, 그래프의 연결성을 그대로 유지하는 **가장 저렴한 그래프**를 찾는 문제
- 중요! **각 간선의 가중치가 동일하지 않을 때 단순히 가장 적은 가중치의 간선을 사용한다고 해서 최소 비용이 얻어지는 것이 아니다.**
- MST 는 각 간선의 가중치를 고려하여 최소 비용의 스패닝 트리를 선택하는 것을 말한다.
- 즉, 네트워크(가중치를 간선에 할당한 그래프)에 있는 모든 정점들을 **가장 적은 수의 "간선" 과 "비용"** 으로 연결하는 것이다.

### 최소 스패닝 트리 (Minimum Spanning Tree, MST) 특징

- 간선의 가중치 합이 최소여야 한다.
- N 개의 정점을 가지는 그래프에 대해서는 N - 1 개의 간선만을 사용해야 한다.
- 사이클이 포함되서는 안된다.

### 최소 스패닝 트리 (Minimum Spanning Tree, MST) 의 적용 사례

- 통신망, 도로망, 유통망에서 길이나 구축비용 그리고 전송 시간등을 최소로 구축하려는 경우

<img src="https://gmlwjd9405.github.io/images/algorithm-mst/mst-example.png" width="500px" height="250px">

- 도로 건설 - 도시들을 모두 연결하면서 **도로의 길이가 최소**가 되도록 하는 문제
- 전기 회로 - 단자들을 모두 연결하면서 **전선의 길이가 최소**가 되도록 하는 문제
- 통신 - **전화선의 길이가 최소**가 되도록 전화 케이블 망을 구성하는 문제
- 배관 - 파이프를 모두 연결하면서 **파이프의 총 길이가 최소**가 되도록 하는 문제

### 최소 스패닝 트리 (Minimum Spanning Tree, MST) 구현 방법

- **크루스칼 알고리즘 (Kruskal MST Algorithm)** - 탐욕적인 방법(Greedy) 을 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것

> 1. 그래프의 모든 간선을 가중치의 오름차순으로 정렬한다.
> 2. 스패닝 트리에 하나씩 추가한다.
> 3. 물론 가중치가 작다고 해서 무조건 간선을 트리에 더하는 것은 아니다. 자칫하다가는 선택한 간선들이 사이클을 이룰 수 있기 때문이다.
> 4. 따라서 결과적으로 사이클이 생기는 간선은 제외한다.
> 5. 모든 간선을 한 번씩 검사하고 난 뒤 종료한다.
>
> - **중요한 부분은 간선을 트리에 추가 했을 때 이미 추가한 간선들과 합쳐 사이클을 이루는지 여부를 판단하는 부분이** > **크루스칼 알고리즘의 핵심이다.**
>
> ```c++
> #include <iostream>
> #include <algorithm>
> #include <vector>
> #include <tuple>
> using namespace std;
> // 트리를 이용해 상호 배제적 집합을 구현한다.
> // 자세한 구현은 종만북 25장 상호 배제적 집합을 참고하자.
> sturct DisjoinSet;
> const int MAX_V = 100;
> // 정점의 갯수
> int v;
> // 그래프의 인접 리스트 (연결된 정점의 번호, 간선의 가중치) 쌍을 담는다.
> vector<pair<int, int> > adj[MAX_V];
>
> // 주어진 그래프에 대해 최소 스패닝 트리에 포함된 간선의 목록을 selected에 저장하고, 가중치의 합을 반환한다.
> int kruskal(vector<pair<int, int> >& selected) {
>   	int cost = 0;
>   	selected.clear();
>   	// tuple(가중치, 정점1, 정점2) 의 목록을 얻는다.
>   	vector<tuple<int, int, int> > edges;
>   	for (int u = 0; u < V; ++u) {
>     		for (int i = 0; i < adj[u].size(); ++i) {
>       			int v = adj[u][i].first;	// 연결된 정점의 번호
>       			int w = adj[u][i].second;	// 가중치
>       			edges.push_back(make_tuple(w, u, v));
>    		}
>   	}
>
>   	// 가중치 순으로 정렬
>   	sort(edges.begin(), edges.end());
>
>   	// 처음엔 모든 정점이 서로 분리되어 있다.
>   	DisjoinSet sets(V);
>   	for (int i = 0; i < edges.size(); ++i) {
>     		// 간선 (u, v)를 검사한다.
>    		int w, u, v;
>     		tie(w, u, v) = edges[i];
>     		// 이미 u와 v가 연결되어 있을 경우 무시 한다.
>     		if (sets.find(u) == sets.find(v)) continue;
>     		// 정점 u와 v를 합친다.
>     		sets.merge(u, v);
>     		selected.push_back(make_pair(u, v));
>    		cost += w;
>   	}
>
>   	return cost;
> }
> ```
>
> - 크루스칼 알고리즘의 시간 복잡도
>   - DisjoinSet에 대해 하는 연산은 현실적으로 상수 시간이다.
>   - 실제 트리를 만드는 for 문의 시간 복잡도는 O(|E|) 라고 봐도 좋다.
>   - 따라서 전체 시간 복잡도는 간선 목록의 정렬에 걸리는 시간 **O( |E| log |E| )** 가 전체 시간 복잡도이다.

- **프림 알고리즘 (Prim MST Algorithm)** - 다익스트라 알고리즘과 거의 같은 형태를 띠고 있는데, 비슷한 알고리즘으로 다른 문제를 어떻게 해결하는지에 중점을 둘 것

> - 크루스칼 알고리즘과 진행 방식이 다르다. 크루스칼 알고리즘에서는 여기저기서 산발적으로 만들어진 트리의 조각을 합쳐 스패닝 트리를 만들지만 프림 알고리즘에서는 하나의 시작점으로 구성된 트리에 간선을 하나씩 추가하며 스패닝 트리가 될때까지 키워 나간다.
> - 핵심은 스패닝 트리에 속하지 않은 각 정점에 대해 트리와 이 정점을 연결하는 가장 짧은 간선에 대한 정보를 저장하고, 각 정점을 순회하면서 다음에 추가할 정점을 찾으면 O(E) 대신에 O(V) 시간에 다음에 추가할 간선을 찾을 수 있다.
> - 프림 알고리즘은 이를 위해 트리와 이 정점을 연결하는 간선의 최소 가중치를 저장하는 배열 minWeight[]를 유지 한다.
> - minWeight[] 배열은 트리에 정점을 새로 추가할 때마다 이 정점에 인접한 간선들을 순회하면서 갱신하게 된다.
>
> ```c++
> const int MAX_V = 100;
> const int INF = 987654321;
> // 정점의 갯수
> int V;
> // 그래프의 인접 리스트 (연결된 정점의 번호, 간선 가중치) 쌍을 담는다.
> vector<pair<int, int> > adj[MAX_V];
> // 주어진 그래프에 대해 최소 스패닝 트리에 포함된 간선의 목록을 selected에 저장하고, 가중치의 합을 반환한다.
> int prim(vector<pair<int, int>& selected) {
>   	selected.clear();
>   	// 해당 정점이 트리에 포함되어 있나?
>   	vector<bool> added(V, false);
>   	// 트리에 인접한 간선 중 해당 정점에 닿는 최소 간선의 정보를 저장한다.
>   	vector<int> minWeight(V, INF);
>   	vector<int> parent(V, -1);
>   	// 가중치 합을 저장할 변수
>   	int cost = 0;
>   	// 0번 정점을 시작점으로 항상 트리에 가장 먼저 추가 한다.
>   	minWeight[0] = parent[0] = 0;
>   	for (iter = 0; iter < V; ++iter) {
>     		// 다음에 트리에 추가할 정점 u를 찾는다.
>     		int u = -1;
>     		for (int v = 0; v < V; ++v) {
>       			if (!added[v] && (u == -1 || minWeight[u] > minWeight[v])) {
>       				u = v;
>       			}
>     		}
>     		// (parent[u], u)를 트리에 추가 한다.
>    		if (parent[u] != u) selected.push_back(make_pair(parent[u], u));
>     		cost += minWeight[u];
>     		added[u] = true;
>     		// u에 인접한 간선 (u, v)들을 검사 한다.
>     		for (int i = 0; i < adj[u].size(); ++i) {
>       			int v = adj[u][i].first;
>       			int w = adj[u][i].second;
>       			if (!added[v] && minWeight[v] > w) {
>         			minWeight[v] = w;
>         			parent[v] = u;
>       			}
>     		}
>   	}
>
>   	return cost;
> }
> ```
>
> - 우선순위 큐를 사용하지 않고 다익스트라 알고리즘을 구현한 것과 비슷한 형태를 갖고 있다.
> - **각 정점에 대해 지금까지 알려진 최단 거리를 저장하는 것이 아니라 마지막 간선의 가중치를 저장하고 있다는점이 다익스트라 알고리즘과 다르다.**
> - 다익스트라 알고리즘에서처럼 우선순위 큐를 사용하도록 하면 O(|E|log|V|)에 프림 알고리즘을 구현하는 것이 가능하다.
> - 이 경우 우선순위 큐는 각 정점의 번호를 minWeight[]이 증가하는 순으로 정렬해 담고있게 된다.

### 다익스트라 알고리즘과 최소 스패닝 트리 (프림 알고리즘)의 차이

- 다익스트라 알고리즘의 경우 **한 노드에서 다른 노드까지 가장 작은 가중치를 가지는 경로이다.**
- 최소 스패닝 트리는 **각 노드들의 가중치가 가장 작은 상태로 모든 정점을 연결하는 것이다.**
- 가장 중요한 것은 가중치를 갱신하는 순간이 다르다.
- 다익스트라의 알고리즘과 구현을 이해하고 있고, 최소 스패닝 트리의 프림 알고리즘의 구현을 이해하고 있다면 다음을 보자

| ![img](https://t1.daumcdn.net/cfile/tistory/990270505B137A262D)_다익스트라 알고리즘_ | ![img](https://t1.daumcdn.net/cfile/tistory/99D926455B137AD812)_최소 신장 트리 알고리즘_ |
| :----------------------------------------------------------------------------------: | :--------------------------------------------------------------------------------------: |
|                                                                                      |                                                                                          |

- 다익스트라의 경우

> 시작 정점(A)에서 A -> B은 5의 비용, A -> C은 7의 비용, A -> D은 3의 비용이 든다. B -> C의 비용이 1인 경우에서 보자면 기존에는 A -> C 이동하면 7의 비용이지만, A -> B -> C 이동한다면 6의 비용으로 기존의 값보다 최소 비용을 갖게 된다.
> 즉, 다익스트라 알고리즘은 **그래프 내의 시작 정점에서 다른 정점으로 향하는 가장 짧은 경로를 구하는 알고리즘이다.**

- 최소 스패닝 트리의 경우

> 시작 정점(A)에서 A -> B은 5의 비용, A -> C은 7의 비용, A -> D은 3의 비용이 든다. 그 다음 내부 알고리즘으로 인해 A 정점을 최소 스패닝 트리에 추가하고 가장 가중치가 작은 D 정점에서 최소 스패닝 트리에 추가된 A 정점을 제외한 B 정점과 C 정점의 가중치를 확인한다. D 정점에서 C 정점을 확인할때 원래 비용은 7로 기록되어있으나 이것은 A -> C 에서 비용이다. 따라서 D 정점에 입장에서는 바라봤을때 자기 자신과 인접한 간선의 가중치를 확인하고 D -> C 간선의 가중치를 4로 갱신한다.
> 즉, 최소 스패닝 트리는 **현재 정점의 입장**에서 **자기 자신과 인접한 간선의 가중치를 확인하고 갱신하는 것**이다.

- A 에서 부터 B 까지의 경로에서 **다익스트라는 A -> B** 이며, **최소 스패닝 트리는 A -> D -> C -> B** 이다.
- 두 개의 알고리즘은 진행 방식이 많이 다르다.

---

## 참고

- [ 알고리즘 - 최소 스패닝 트리(Minimum Spanning Tree, MST)란 ](https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html)
- 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만)
- [최소 스패닝 트리와 다익스트라의 차이](https://red-pulse.tistory.com/120)
