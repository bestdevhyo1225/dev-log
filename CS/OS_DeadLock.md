# 교착상태 (DeadLock)

## 교착상태란?

- 두 개 이상의 프로세스 혹은 스레드가 서로가 가진 리소스를 기다리는 상태를 의미한다.

## 교착상태를 만드는 4가지 조건

> 상호 배제 (Mutual Exclusion)

- 리소스(Resource)를 공유해서 사용할 수 없다.
- 한 번에 하나의 프로세스 혹은 스레드가 리소스를 사용할 수 있다.

> 잡고 기다리기 (Hold and Wait)

- 프로세스/스레드가 이미 하나 이상의 리소스를 `취득한(hold)` 상태에서 다른 프로세스/스레드가 사용하고 있는 리소스를 추가로 `기다리는(wait)` 것을 의미한다.

> 비선점 (Non Preemption)

- 리소스 반환은 오직 그 리소스를 획득한 프로세스/스레드에서만 할 수 있다.
- 이미 하나의 프로세스/스레드에서 리소스를 가지고 있다면, 다른 프로세스/스레드에서 그 리소스를 빼앗을 수 없다.

> 순환 대기 (Circular Wait)

- 프로세스/스레드들이 `순환(wait)` 형태로 서로의 리소스를 기다린다.

## 교착상태(DeadLock)를 이해할 수 있는 그림

<img width="777" alt="스크린샷 2023-06-10 오후 8 35 46" src="https://github.com/bestdevhyo1225/dev-log/assets/23515771/f8e2d3f4-905f-4ee8-a811-aba6611415c9">

- 위의 그림은 교착상태 4가지
  조건인 `상호 배제(Mutual Exclusion)`, `잡고 기다리기(Hold and Wait)`, `비선점(Non Preemption)`, `순환 대기(Circular Wait)` 를 모두 만족하기 때문에
  교착상태(DeadLock)이 발생한다.

## OS의 교착상태(DeadLock) 해결 방법

### 교착상태(DeadLock) 방지

- 시스템 레벨에서 디자인을 하는 것인데, 4가지 조건 중 하나가 충족되지 않게 설계하는 방법이다.

> 상호 배제(Mutual Exclusion) 방지하기

- 리소스를 공유 가능하게 하는 것인데, 현실적으로 이 방법은 불가능하다.

> 잡고 기다리기 (Hold and Wait) 방지하기

- 사용할 리소스들을 모두 획득한 뒤에 시작한다.
- 리소스를 전혀 가지지 않은 상태에서만 리소스를 요청한다.

> 비선점 (Non Preemption) 방지하기

- 추가적인 리소스를 기다려야 한다면, 이미 획득한 리소스를 다른 프로세스가 선점 가능하도록 한다.

> 순환 대기 (Circular Wait) 방지하기

- 모든 리소스를 순서 체계를 부여해서 오름차순으로 리소스를 요청한다.
- 4가지 방지 방법 중에서는 가장 많이 사용되는 방식이라고 한다.

### 교착상태(DeadLock) 회피

- 실행 환경에서 추가적인 정보를 활용해서 교착상태(DeadLock)가 발생할 것 같은 상황을 회피하는 것이다.

> Banker Algorithm

- 리소스 요청을 허락했을 때 교착상태(DeadLock) 발생 가능성이 있으면, 리소스를 할당해도 안전할 때까지 계속 요청을 거절하는 알고리즘

### 교착상태(DeadLock) 감지와 복구

- 교착상태(DeadLock)를 허용하고, 발생하면 복구하는 전략이다.

> 복구 전략

- 프로세스를 강제로 종료시킨다.
- 하나씩 프로세스를 강제로 종료시키는 방법이 있다.

### 교착상태(DeadLock) 무시

- 그냥 무시하는 방법 (개발자가 알아서 하겠지)
- 많은 운영체제들이 은근히 이러한 방법을 사용한다.

## Java 교착상태(DeadLock) 예제

<img width="1000" alt="스크린샷 2023-06-10 오후 9 01 57" src="https://github.com/bestdevhyo1225/dev-log/assets/23515771/52263727-0ac7-46f9-bf1c-5980c59114e3">

- 교착상태(DeadLock)이 발생하는 코드이다.
- 개발할 때, 상호 배제(Mutual Exclusion)가 반드시 필요한 것인지 꼭 생각을 해봐야 한다.
    - 너무 남발한 것은 아닌지?
    - 상호 배제(Mutual Exclusion)을 사용하지 않고도 해결할 방법은 없었는지?
- 위의 코드의 교착상태(DeadLock)을 해결하려면, `T1` 스레드에서 `lock1 -> lock2` 순서로 잠금을 획득하는 것처럼 `T2` 스레드도 동일하게 `lock1 -> lock2` 순서로 잠금을
  획득하도록 코드를 수정하면 된다.

## 참고

- [교착상태(DeadLock) 설명 영상 보기](https://www.youtube.com/watch?v=ESXCSNGFVto&list=PLcXyemr8ZeoQOtSUjwaer0VMJSMfa-9G-&index=7)
