## 색인(Index)이란??

<br>

### :book: 데이터베이스에서 인덱스란 무엇인가요?

* 느린 디스크 I/O를 위해서 색인(Index)구조가 필요하고 이것이 바로 `인덱스`이다.

* 테이블에서 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 컬럼들의 값과 해당 레코드가 저장된 주소를 키와 값(Key-Value Pair)의 쌍으로 인덱스를 만들어 두는 것이다.

* 프로그래밍 언어의 자료구조로 `인덱스`와 `데이터 파일`을 비교하자면?

  * `인덱스`는 `SortedList`와 유사하다.

  * `데이터 파일`은 `ArrayList`와 유사하다.

* 인덱스는 데이터들을 정렬해서 관리하고 있으며, 데이터가 저장, 삭제, 갱신될 때마다 항상 값을 정렬해야 하므로 과정이 복잡하고 느리다. 그러나 이미 정렬돼 있어서 원하는 값을 아주 빨리 찾아올 수 있다.

* 데이터 중복 허용 여부로 `유니크 인덱스(Unique Index)` 와 `유니크 하지 않은 인덱스(Non-Unique Index)`로 구분할 수 있다.

* 유니크 인덱스는 실제 쿼리를 실행해야 하는 `옵티마이저`에게는 상당히 중요한 문제이다. 왜냐하면 유니크 인덱스에 대해 동등 조건(Equal, =)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 `옵티마이저`에게 알려주는 효과를 낸다.

<br>

### :book: B-Tree 인덱스

* 컬럼의 원래 값을 변형시키지 않고(물론 값의 앞부분만 잘라서 관리하기는 하지만), 인덱스 구조체 내에서는 항상 정렬된 상태로 유지하고 있다.

* `루트 노드`와 `브랜치 노드`는 자식 노드의 주소를 가지고 있으며, `리프 노드`는 **데이터 레코드를 찾아가기 위한 주소값을 가지고 있다.**

* 인덱스의 키 값은 모두 정렬돼 있지만, 파일 레코드는 정렬돼 있지 않고 임의의 순서대로 있다. 

  * InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서대로 정렬되어 저장된다.