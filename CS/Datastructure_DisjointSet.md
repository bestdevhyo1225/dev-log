## 상호 배타적 집합 (Disjoint Set)
---



### 상호 배타적 집합

* 어떤 파티에 N명의 사람들이 왔다고 한다. 레크레이션 강사가 이 중에서 생일이 같은 사람들끼리 팀을 구성하라고 소리친다.
* 처음에는 누가 자신과 생일이 같은지 모르기 때문에 혼자 돌아다니지만, 생일이 같은 사람을 한 번 찾으면 이 둘은 팀을 이뤄 같이 움직인다.
* 그리고 다른 팀과 생일이 같다는 것을 확인하면 곧장 두 팀은 합쳐진다.
* 파티에 온 사람들의 전체 집합을 두고 보면, 팀은 이 집합을 여러 개의 부분 집합들로 쪼갠 것이다.
* 각 팀은 생일이 같은 사람들로 구성되어 있기 때문에 두 개 이상의 팀에 속한 사람은 없다는 점에 유의하자
* 이렇게 공통 원소가 없는, 다시 말해 상호 배타적인 부분 집합들로 나눠지 원소들에 대한 정보를 저장하고 조작하는 자료 구조가 바로 **유니온-파인드** 자료구조이다.



### 유니온 - 파인드 자료구조 표현 (독특한 트리 형태의 자료구조)

* 초기화 : N 개의 원소가 각각의 집합에 포함되어 있도록 초기화 한다.
* 합치기 (union) 연산 : 두 원소 a, b 가 주어질 때 이들이 속한 두 집합을 하나로 합친다.
* 찾기 (find) 연산 : 어떤 원소 a 가 주어질 때 이 원소가 속한 집합을 반환 한다.



### 배열로 상호 배타적 집합 표현하기

```C++
belongsTo[i] = i // i번 원소가 속하는 집합의 번호

// 크기가 1인 N개의 집합을 쉽게 만들 수 있다.
// 찾기 연산을 상수 시간에 구현할 수 있다.
// 문제가 되는 경우는 합치기 연산이다.
// 모든 원소를 순회하면서 한 쪽 집합에 속한 원소들을 다른 쪽 집합으로 옮겨 주어야 하는데,
// belonsTo[]의 모든 원소를 순회하는 데 O(n)의 시간이 걸린다.
// 합치기 연산을 빠르게 할 수 있는 방법을 원하게 된다..
```



### 트리를 이용한 상호 배타적 집합의 표현

* 한 집합에 속하는 원소들을 하나의 트리로 묶어 준다.
* 상호 배타적 집합 자료 구조는 트리들의 집합으로 표현 된다.
* 트리에서 **찾기 연산**은 주어진 원소가 포함된 **트리의 루트** 를 찾는 것으로 구현된다.
* 모든 자식 노드가 부모에 대한 포인터를 가지고 있어야 한다.
* 부모에서 자식으로 내려갈 일은 없기 때문에 부모는 자기 자신을 가리키도록 구현한다.
* 트리에서 **합치기 연산**은 각 트리의 루트를 찾은 뒤, 하나를 다른 루트의 자손으로 넣으면 된다.



### 상호 배타적 집합의 최적화

* 구현을 하다보면 트리가 한쪽으로 기울어지는 오류를 범하게 되고 이 것은 N - 1인 연결리스트가 되버린다. 트리의 높이가 O(N) 이 되면 합치기, 찾기 연산도 O(N)이 되어 버린다. 애초에 배열로 구현하던 것보다도 효율이 나빠진다.
* 이와 같은 문제를 해결하는 방법은 여러 가지 방법들이 있는데 그 중에서 쉽게 생각할 수 있는 방법은 **두 트리를 합칠 때 항상 높이가 더 낮은 트리를 높은 트리 밑에 집어 넣음으로써 트리의 높이가 높아지는 상황을 방지하는 것이다.**
* 이 최적화를 **랭크에 의한 합치기(union-by-rank) 최적화** 라고 부른다.

```c++
#include <vector>
#include <algorithm>
using namespace std;
// 트리를 이용해 상호 배타적 집합을 구현한다.
struct OptimizedDisjointSet {
	// rank[]는 해당 노드가 한 트리의 루트인 경우 해당 트리의 높이를 저장한다.
  vector<int> parent, rank;
  OptimizedDisjointSet(int n) : parent(n), rank(n, 1) {
    for (int i = 0; i < n; i++) parent[i] = i;
  }
  
  // u가 속한 트리의 루트 번호를 반환한다.
  int find(int u) {
    if (u == parent[u]) return u;
    return parent[u] = find(parent[u]);
  }
  
  // u가 속한 트리와 v가 속한 트리를 합친다.
  void merge(int u, int v) {
    u = find(u);
    v = find(v);
    // u와 v가 이미 같은 집합에 속하는 경우를 걸러낸다.
    if (u == v) return;
    if (rank[u] > rank[v]) swap(u, v);
    // 이제 rank[v]가 항상 rank[u] 이상이므로 u를 v의 자식으로 넣는다.
    parent[u] = v;
    // 두 트리의 높이가 같은 경우에만 결과 트리의 높이 1을 늘려준다.
    if (rank[u] == rank[v]) ++rank[v];
  }
};
```

* 트리의 높이는 포함한 노드의 수의 로그에 비례 합치기 연산과 찾기 연산의 시간 복잡도는 O(N) 이 아니라 O(logN) 이 된다.
* find(u) 를 통해 u가 속하는 트리의 루트를 찾아냈다. 이때 parent[u]를 찾아낸 루트로 아예 바꿔 버리면 다음번에 find(u)가 호출되었을때는 경로를 따라 올라갈 것 없이 바로 루트를 찾을 수 있다. 이런 최적화를 **경로 압축(path compression) 최적화** 라고 부른다.



---

## 참고

* 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만)