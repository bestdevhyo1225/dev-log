# MySQL 쿼리 최적화 JOIN

## :book: JOIN의 순서와 인덱스

우선 `인덱스 레인지 스캔` 으로 레코드를 읽는 작업은 다음과 같다.

1. 인덱스 조건을 만족하는 값이 지정된 위치를 찾는다. -> `인덱스 탐색(Index Seek)`

2. 1번에서 탐색된 위치에서 필요한 만큼 인덱스를 쭉 읽는다. -> `인덱스 스캔(Index Scan)`

3. 2번에서 읽어들인 `인덱스 키`와 `레코드 주소`를 이용해 레코드가 저장된 페이지를 가져오고 `최종 레코드`를 읽어온다.

조인 작업에서 `드라이빙 테이블(Driving)` 을 읽을 때와 `드리븐 테이블(Driven)` 을 읽을 때를 확인해 보면 다음과 같다.

- **드라이빙 테이블 (Driving Table)**
    - `인덱스 탐색` 작업을 1번 수행하고, 그 이후부터는 `인덱스 스캔`만 실행하면 된다.
- **드리븐 테이블 (Driven Table)**
    - `인덱스 탐색`과 `인덱스 스캔` 작업을 드라이빙 테이블에서 읽은 레코드 건 수 만큼 반복한다.

따라서 `드리븐 테이블(Driven Table)` 을 읽는 것이 훨씬 큰 부하를 차지한다. 그래서 `옵티마이저` 는 항상 드라이빙 테이블이 아닌 `드리븐 테이블(Driven Table) 을 최적으로 읽을 수 있게 실행
계획을 수립한다.` ( MySQL JOIN은 Nested Loop를 따르기 때문에...)

## :book: 예제를 보면서 확인해보자!

```sql
SELECT *
FROM employees AS e,
     dept_emp AS de
WHERE e.emp_no = de.emp_no;
```

`두 컬럼 모두 인덱스가 있는 경우`

- 각 테이블의 통계 정보에 있는 레코드 건수에 따라 employees가 드라이빙 테이블이 될 수도 있고, dept_emp 테이블이 드라이빙 테이블로 선택될 수도 있다. 어느 쪽 테이블이 드라이빙 테이블이 되든
  옵티마이저가 선택하는 방법이 최적일 때가 많다.

`employees.emp_no 에만 인덱스가 있는 경우`

- 이 때 옵티마이저는 employees 테이블을 드리븐 테이블로 선택해서 인덱스 스캔을 진행하고, dept_emp 테이블을 드라이빙 테이블로 선택해서 풀 스캔을 진행한다. (드리븐 테이블 읽는 것을 최소화 해야
  하기 때문에 인덱스 스캔)

`dept_emp.emp_no 에만 인덱스가 있는 경우`

- 이 때 옵티마이저는 dept_emp 테이블을 드리븐 테이블로 선택해서 인덱스 스캔을 진행하고, employees 테이블을 드라이빙 테이블로 선택해서 풀 스캔을 진행한다. (드리븐 테이블 읽는 것을 최소화 해야
  하기 때문에 인덱스 스캔)

`두 컬럼 모두 인덱스가 없는 경우`

- 어떤 테이블을 선택하더라도 드리븐 테이블의 풀 스캔은 발생하기 때문에 옵티마이저가 적절히 드라이빙 테이블을 선택한다. 단 레코드 건수가 적은 테이블을 드리븐 테이블로 선택하는 것이 효율적이다. 또한 드리븐
  테이블을 읽을 때 조인 버퍼가 사용되기 때문에 실행 계획의 Extra 칼럼에 "Using join buffer" 가 표시된다.

## :book: Nested Loop Join 정리

```sql
SELECT *
FROM A a
         INNER JOIN B a ON a.id = b.id;
```

```sql
SELECT *
FROM A a,
     B b
WHERE a.id = b.id;
```

- `Join` 이 일어나면 두 테이블의 인덱스 유무를 살핀다.
- 인덱스가 있는 테이블을 `드리븐` 으로 둔다.
    - 드라이빙 테이블이 드리븐 테이블에 대해서 Full Scan을 하지 않아 더 빠르기 때문
    - 드리븐 테이블은 인덱스 탐색(Index Seek), 인덱스 스캔(Index Scan) 작업이 드라이빙 테이블 레코드 수 만큼 진행되기 때문에 최적화를 위해 인덱스가 있는 테이블을 드리븐으로 둔다.
- 양 쪽 모두 인덱스가 있거나 모두 없는 경우
    - 각 테이블의 레코드 건 수, 이외의 통계 정보등을 통해 드라이빙 테이블을 판단한다.
- 드라이빙 테이블이 100건이고 드리븐 테이블이 1000건일 경우 조인 횟수는 100 X 1000이고, 반대의 경우에도 어차피 1000 X 100으로 똑같지 않나라는
  의문이 들었다. 하지만 이거는 인덱스가 없을 때나 해당된다.
- 다른 블로그 글을 찾아보니 드라이빙 테이블의 대상 건수를 줄이는 이유는 `드라이빙 테이블의 추출 건수가 곧 드리븐 테이블의 액세스 반복 횟수` 가 되므로 `데이터가 더 적은 테이블이 드라이빙 테이블로 선정되어야
  한다.` 라고 설명이 되어 있었다.
    - 둘 다 인덱스가 있다면, 옵티마이저는 데이터 건수가 더 적은 테이블을 드라이빙 테이블로 선정한다.

```markdown
A: 3,000만 건
B: 1,000만 건 (B 테이블에 인덱스가 있는 경우)
```

- A 테이블에서 3,000만 개의 데이터가 존재하기 때문에 3,000만 번의 접근
- A 테이블의 각각의 Row는 B 테이블 인덱스의 1번씩 접근하여 B 테이블과 조인하기 때문에 3,000만 번 접근하여 B 테이블과 조인한다.
- 총 6,000만 번의 액세스가 일어난다.

```markdown
A: 1,000만 건
B: 3,000만 건 (B 테이블에 인덱스가 있는 경우)
```

- A 테이블에서 1,000만 개의 데이터가 존재하기 때문에 1,000만 번의 접근
- A 테이블의 각각의 Row는 B 테이블 인덱스의 1번씩 접근하여 B 테이블과 조인하기 때문에 1,000만 번 접근하여 B 테이블과 조인한다.
- 총 2,000만 번의 액세스가 일어난다.

## :book: Nested Loop Join 방식 특징 및 주의 사항

### 특징

- 주로 좁은 범위에 유리
- 순차적으로 처리하며, Random Access 위주
- 후행(Driven) 테이블에는 조인을 위한 인덱스가 생성되어 있어야 한다.

### 주의 사항

- 데이터를 랜덤으로 액세스하기 때문에 결과 집합이 많으면 수행속도가 저하됨
- 선행(Driving) 테이블의 크기가 작거나, Where절 조건을 통해 결과 집합을 제한할 수 있어야 한다.
- 조인 연결고리 인덱스가 없거나, 조인 집합을 구성하는 검색 조건이 조인 범위를 줄여주지 못할 경우 비효율적이다.

## :book: Application 레벨에서 Join을 지양해야 하는 이유

- 결합 쿼리는 장기적인 관점에서 `데이터 증가에 따라 통계 혹은 힌트의 변화로 옵티마이저가 동작하는 방식이 변경될 수 있기에 성능 저하의 주범` 이 될 수 있다. 또한, bulk data가 쌓이면 쌓일수록 메모리
  이슈도
  발생할 수 있다.

## :bookmark: 참고

- Real MySQL - 쿼리 최적화 JOIN
- [[Database] Nested Loop 최적화](https://insight-bgh.tistory.com/500)
- [[데이터베이스] SQL 튜닝 - 드라이빙 테이블](https://programming-workspace.tistory.com/67)
