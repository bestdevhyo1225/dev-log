# 리눅스 성능 분석 시작하기 - 트러블 슈팅 사례

## :pushpin: 목차

- [Nginx Miss Configuration](https://github.com/bestdevhyo1225/dev-log/blob/master/Monitoring/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%84%B1%EB%8A%A5_%EB%B6%84%EC%84%9D_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0_%ED%8A%B8%EB%9F%AC%EB%B8%94_%EC%8A%88%ED%8C%85_%EC%82%AC%EB%A1%80.md#pushpin-nginx-miss-configuration)
- [간헐적인 네트워크 응답 지연](https://github.com/bestdevhyo1225/dev-log/blob/master/Monitoring/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%84%B1%EB%8A%A5_%EB%B6%84%EC%84%9D_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0_%ED%8A%B8%EB%9F%AC%EB%B8%94_%EC%8A%88%ED%8C%85_%EC%82%AC%EB%A1%80.md#pushpin-%EA%B0%84%ED%97%90%EC%A0%81%EC%9D%B8-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%91%EB%8B%B5-%EC%A7%80%EC%97%B0)

## :pushpin: Nginx Miss Configuration

### 장애 상황

- 트래픽 증가와 함께 `서버의 응답 지연` 이 발생했다.
- `응답 지연` 은 `컴퓨터 리소스 부족` 이 원인에 의해서 발생했다.

### 메트릭 수집

- `CPU Usage` : CPU 사용량이 많아서 응답을 못하는 것인가?
- `Memory Usage` : 메모리 사용량이 많아서 OOM 에러가 발생하는 것인가?

### 분석

- `top` 명령을 이용해서 `CPU Usage` 를 확인하기
- 멀티 코어의 경우, 반드시 `모든 코어의 사용률을 확인해야 한다.`
- `8개의 CPU` 중 `1개의 CPU 사용률만 100%` 인 경우, `정상이 아니다.`

### worker_processes

- nginx의 설정 중 `Worker Process` 의 개수를 설정하는 항목이다.
- `Worker Process` 는 사용자 요청을 처리하는 중요한 프로세스이다.
- `worker_processes` 값을 `1` 에서 `auto` 로 바꾸게 되면, `8개의 Worker Process` 가 생기고, `서버를 8배 늘린것과 같은 효과` 를 볼 수 있다.
    - [참고) nginx.conf 파일에서 worker_processes 기본 값은 1로 설정되어 있다.](https://github.com/nginx/nginx/blob/master/conf/nginx.conf)

### Lesson Learned

- `CPU Usage` 모니터링을 잘해야한다.
- `CPU 전체 사용률` 을 보면 안된다. 멀티 코어인 경우, `개별 CPU 사용률` 을 확인해야 한다.
    - 예시) `CPU 전체 사용률이 15%`, `CPU 8개 중에 1개만 100%` 인 경우

## :pushpin: 간헐적인 네트워크 응답 지연

### 장애 현상

- 간헐적으로 API 호출시, 타임아웃이 발생한다.

### 메트릭 수집

- `netstat` 을 통해 네트워크 연결은 잘 되어 있는지 확인한다.
- `tcpdump` 를 통해 패킷들의 흐름을 수집 후, 분석한다.

### tcpdump 낚시

```shell
$ tcpdump -vvv -nn -A -G 3600 -w /var/log/tcpdump/$(hostname)_%Y%m%d-%H%M%S.pcap
```

- 간헐적인 타임아웃은 긴 호흡으로 패킷을 수집해야 한다.
- `-G` 옵션은 `tcpdump` 가 파일을 갱신하는 주기이다.
    - `3,600초` -> `1시간`

### 타임아웃이 발생한 순간의 pcap을 분석

<img width="700" alt="스크린샷 2023-08-12 오전 10 59 37" src="https://github.com/bestdevhyo1225/dev-log/assets/23515771/8fb66cc1-a2cb-4125-b427-3667df6a088f">

- POST 요청을 보내고 3초 후에 FIN 패킷이 날라갔는데, POST에 대한 응답이 5초 후에 도착했다.
- 클라이언트가 3초를 기다렸는데, 응답이 안왔으니깐 FIN 패킷을 보냈다.
- 그런데 POST 응답을 5초 후에 보냈기 때문에 기다렸으면, 응답을 받을 수 있었다.

### 클라이언트의 타임아웃 설정

#### Timeout

- 현재 상태가 정상이라고 판단할 때까지 얼마나 기다릴 것인가?
- 기다리는 시간이 지나면, 정상이 아니다. (에러)

#### Connection Timeout

- 종단 간 연결을 처음 맺을 때, 사용되는 타임아웃이다.
- `TCP 3-Way Handshake` 할때, 사용되는 것이 `Connection Timeout` 이다.

#### Read Timeout

- 종단 간의 연결을 맺은 후 데이터를 주고 받을 때, 사용되는 타임아웃이다.
- `GET`, `POST`, `PATCH`, `PUT`, `DELETE` 를 통해 데이터를 주고 받을때, 사용되는 것이 `Read Timeout` 이다.

#### Round Trip Time (RTT)

- 패킷이 종단 간을 이동할 때 걸리는 시간을 의미한다. 즉, 물리적 거리에 따른 시간을 말한다.
- 예시) 서울과 부산을 왕복하는 것보다 서울과 뉴욕을 왕복할 때 시간이 더 걸린다.

#### Timeout 설정 시, 고려 사항

<img width="700" alt="스크린샷 2023-08-12 오전 11 12 13" src="https://github.com/bestdevhyo1225/dev-log/assets/23515771/164ccc36-9d32-4907-9878-e547d3af6223">

- 응답에 소요되는 시간과 RTT를 함께 고려해야 한다.

#### 두 가지 고려해야 할 것

1. RTT를 모를 때
2. 패킷이 유실되었을 때

#### RTT를 모를 때

- 종단 간의 커넥션을 처음 맺을 때는 패킷이 한 번도 흘러본 적이 없으니 시간이 얼마나 걸릴지 알 수 없다.
- `initRTO` 라는 개념을 사용해서 해결한다.
- `initRTO` 는 RTT를 모를 때 사용하는 커널의 패킷 초기 타임아웃 값을 의미한다.

<img width="700" alt="스크린샷 2023-08-12 오전 11 19 31" src="https://github.com/bestdevhyo1225/dev-log/assets/23515771/bccbe755-4d86-40d0-bccd-f78d7973cc3a">

<img width="700" alt="스크린샷 2023-08-12 오전 11 21 13" src="https://github.com/bestdevhyo1225/dev-log/assets/23515771/6c03147a-73e4-4fa4-bd8f-8bcb75d54f69">

- `initRTO` 기준으로 `SYN` 패킷에 대한 재전송이 `1초 -> 2초 -> 4초` 로 늘어난다.

> Connection Timeout 설정

- **`Connection Timeout`** 을 설정할 때는 `TCP 3-Way Handshake` 과정 중 `최소한 한 번의 패킷 유실 정도는 방어` 할 수 있어야 한다.
    - 그래서 `3초(1초 + RTT 고려)` 정도로 설정하는 것이 좋다.

#### 패킷이 유실되었을 때

- `Retransmission TimeOut(RTO)` 개념을 통해 패킷에 대한 응답이 `RTO` 내에 도착하지 않으면, 유실로 간주한다.
- `RTO` 는 `RTT` 기반으로 계산된다.
- 하지만 `RTT` 가 아무리 짧아도 `RTO` 의 최소값은 있다.
    - `1/5초 = 200ms`

<img width="700" alt="스크린샷 2023-08-12 오전 11 28 23" src="https://github.com/bestdevhyo1225/dev-log/assets/23515771/2cb310ab-8864-4335-8f6b-3b0becb30102">

- `RTT` 가 `10ms` 라고 가정하면, `310ms` 에 처리 가능한 요청이 중간에 패킷 유실로 인해 `200ms` 를 기다리게 되고, 최종적으로 `510ms` 가 소요된다.

> Read Timeout 설정

- **`Read Timeout`** 을 설정할 때는 처리 시간을 고려하고, `최소한 한 번의 패킷 유실을 방어` 할 수 있어야 한다.
    - 그래서 `1초(처리 시간 + RTO 고려)` 정도로 설정하는 것이 좋다.
    - 그런데 `처리 시간` 은 각자의 환경에 맞게 충분히 고려해서 `Read Timeout` 을 설정해야 한다.
- `처리 시간` 이 `1초` 가 넘는다면, `Read Timeout` 이 `1초` 이기 때문에 타임아웃 에러가 빈번하게 발생할 수 있다.

### 타임아웃이 발생한 순간의 pcap을 다시 분석 해보자면

<img width="700" alt="스크린샷 2023-08-12 오전 10 59 37" src="https://github.com/bestdevhyo1225/dev-log/assets/23515771/8fb66cc1-a2cb-4125-b427-3667df6a088f">

- `2894` 와 `2897` 간에 `3초` 가 걸렸는데, 이 의미는 `Read Timeout` 이 `3초` 가 걸렸다는 의미이다.
- 그래서 `3초` 동안 기다렸는데도 응답이 없고, 문제가 있으니 FIN 패킷을 보내 끊어버린 것이다.
- 그런데 이 요청의 경우에는 `처리 시간` 이 `5초` 가 소요되기 때문에 클라이언트 입장에서는 `Read Timeout` 을 `6초` 로 설정했어야 했다.

### Lesson Learned

- 환경에 적합한 타임아웃 값을 설정해야 한다.

## 참고

- [인프런 - 리눅스 성능 분석 시작하기](https://www.inflearn.com/course/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EB%B6%84%EC%84%9D-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/dashboard)
